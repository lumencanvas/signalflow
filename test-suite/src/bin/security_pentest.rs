//! Security Penetration Tests for CLASP
//!
//! These tests verify that the CLASP security model is actually enforced at the protocol level.
//! They attempt various attack vectors against a router running in Authenticated mode.
//!
//! Run with: cargo run -p clasp-test-suite --bin security-pentest

use clasp_core::{
    codec, Action, CpskValidator, HelloMessage, Message, Scope, SecurityMode, SetMessage,
    SubscribeMessage, TokenInfo, Value,
};
use clasp_router::{Router, RouterConfig};
use clasp_transport::{
    Transport, TransportEvent, TransportReceiver, TransportSender, WebSocketTransport,
};
use std::sync::Arc;
use std::time::Duration;
use tokio::net::TcpListener;
use tokio::time::timeout;

// ============================================================================
// Test Infrastructure
// ============================================================================

struct TestResult {
    name: &'static str,
    passed: bool,
    duration: Duration,
    error: Option<String>,
}

struct TestSuite {
    results: Vec<TestResult>,
}

impl TestSuite {
    fn new() -> Self {
        Self {
            results: Vec::new(),
        }
    }

    fn add_result(&mut self, result: TestResult) {
        let status = if result.passed {
            "\x1b[32mPASS\x1b[0m"
        } else {
            "\x1b[31mFAIL\x1b[0m"
        };
        println!("[{}] {} ({:.2?})", status, result.name, result.duration);
        if let Some(ref err) = result.error {
            println!("      Error: {}", err);
        }
        self.results.push(result);
    }

    fn print_summary(&self) {
        let passed = self.results.iter().filter(|r| r.passed).count();
        let failed = self.results.iter().filter(|r| !r.passed).count();
        println!("\n===========================================================================");
        println!(
            "SECURITY PENTEST SUMMARY: Total: {} | Passed: {} | Failed: {}",
            self.results.len(),
            passed,
            failed
        );
        println!("===========================================================================\n");
    }

    fn all_passed(&self) -> bool {
        self.results.iter().all(|r| r.passed)
    }
}

async fn run_test<F, Fut>(name: &'static str, test_fn: F) -> TestResult
where
    F: FnOnce() -> Fut,
    Fut: std::future::Future<Output = Result<(), String>>,
{
    let start = std::time::Instant::now();
    let result = test_fn().await;
    TestResult {
        name,
        passed: result.is_ok(),
        duration: start.elapsed(),
        error: result.err(),
    }
}

async fn find_available_port() -> u16 {
    let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
    listener.local_addr().unwrap().port()
}

/// Create a secure router with CPSK authentication
async fn create_secure_router() -> (String, Arc<CpskValidator>, tokio::task::JoinHandle<()>) {
    let port = find_available_port().await;
    let addr = format!("127.0.0.1:{}", port);
    let url = format!("ws://{}", addr);

    // Create CPSK validator with test tokens
    let validator = Arc::new(CpskValidator::new());
    let validator_for_router = validator.clone();

    // Create a wrapper struct that can be owned by the router
    struct ValidatorWrapper(Arc<CpskValidator>);
    impl clasp_core::TokenValidator for ValidatorWrapper {
        fn validate(&self, token: &str) -> clasp_core::ValidationResult {
            self.0.validate(token)
        }
        fn name(&self) -> &str {
            "CPSK"
        }
        fn as_any(&self) -> &dyn std::any::Any {
            self
        }
    }

    let router = Router::new(RouterConfig {
        name: "Security Test Router".to_string(),
        max_sessions: 100,
        session_timeout: 60,
        features: vec!["param".to_string(), "event".to_string()],
        security_mode: SecurityMode::Authenticated,
        max_subscriptions_per_session: 1000,
        gesture_coalescing: true,
        gesture_coalesce_interval_ms: 16,
    })
    .with_validator(ValidatorWrapper(validator_for_router));

    let handle = tokio::spawn({
        let addr = addr.clone();
        async move {
            let _ = router.serve_websocket(&addr).await;
        }
    });

    // Wait for server to start
    tokio::time::sleep(Duration::from_millis(100)).await;

    (url, validator, handle)
}

/// Connect and complete handshake, returning error message if auth fails
async fn connect_with_token(
    url: &str,
    token: Option<&str>,
) -> Result<(impl TransportSender, impl TransportReceiver), String> {
    let (sender, mut receiver) = WebSocketTransport::connect(url)
        .await
        .map_err(|e| format!("Connection failed: {:?}", e))?;

    // Send HELLO with optional token
    let hello = Message::Hello(HelloMessage {
        version: 2,
        name: "Test Client".to_string(),
        features: vec!["param".to_string()],
        capabilities: None,
        token: token.map(|s| s.to_string()),
    });

    sender
        .send(codec::encode(&hello).unwrap())
        .await
        .map_err(|e| format!("Send failed: {:?}", e))?;

    // Wait for response (WELCOME or ERROR)
    let response = timeout(Duration::from_secs(2), async {
        loop {
            if let Some(event) = receiver.recv().await {
                match event {
                    TransportEvent::Data(data) => {
                        let (msg, _) =
                            codec::decode(&data).map_err(|e| format!("Decode failed: {:?}", e))?;
                        return Ok::<_, String>(msg);
                    }
                    TransportEvent::Disconnected { reason } => {
                        return Err(format!("Disconnected: {:?}", reason));
                    }
                    _ => continue,
                }
            }
        }
    })
    .await
    .map_err(|_| "Timeout waiting for response".to_string())??;

    match response {
        Message::Welcome(_) => Ok((sender, receiver)),
        Message::Error(err) => Err(format!("Auth error {}: {}", err.code, err.message)),
        other => Err(format!("Unexpected response: {:?}", other)),
    }
}

/// Try to send SET and check if it succeeds or fails
async fn try_set<S: TransportSender, R: TransportReceiver>(
    sender: &S,
    receiver: &mut R,
    address: &str,
    value: Value,
) -> Result<bool, String> {
    let set = Message::Set(SetMessage {
        address: address.to_string(),
        value,
        revision: None,
        lock: false,
        unlock: false,
    });

    sender
        .send(codec::encode(&set).unwrap())
        .await
        .map_err(|e| format!("Send failed: {:?}", e))?;

    // Wait for ACK or ERROR
    let response = timeout(Duration::from_secs(2), async {
        loop {
            if let Some(TransportEvent::Data(data)) = receiver.recv().await {
                let (msg, _) =
                    codec::decode(&data).map_err(|e| format!("Decode failed: {:?}", e))?;
                match msg {
                    Message::Ack(_) => return Ok::<_, String>(true),
                    Message::Error(_) => return Ok(false),
                    Message::Set(_) => continue, // Echo of our own SET
                    Message::Snapshot(_) => continue,
                    _ => continue,
                }
            }
        }
    })
    .await
    .map_err(|_| "Timeout waiting for response".to_string())??;

    Ok(response)
}

// ============================================================================
// Security Pentest Cases
// ============================================================================

/// Test 1: Connection without token should be rejected in Authenticated mode
async fn test_no_token_rejected() -> TestResult {
    run_test("Auth: Connection without token rejected", || async {
        let (url, _validator, handle) = create_secure_router().await;

        let result = connect_with_token(&url, None).await;

        handle.abort();

        match result {
            Err(e)
                if e.contains("300") || e.contains("Unauthorized") || e.contains("Auth error") =>
            {
                Ok(())
            }
            Err(e) => Err(format!("Expected Unauthorized error, got: {}", e)),
            Ok(_) => Err("Connection should have been rejected without token".to_string()),
        }
    })
    .await
}

/// Test 2: Connection with invalid token should be rejected
async fn test_invalid_token_rejected() -> TestResult {
    run_test("Auth: Invalid token rejected", || async {
        let (url, _validator, handle) = create_secure_router().await;

        let result = connect_with_token(&url, Some("cpsk_invalid_token_12345678901234567")).await;

        handle.abort();

        match result {
            Err(e)
                if e.contains("300") || e.contains("Unauthorized") || e.contains("not found") =>
            {
                Ok(())
            }
            Err(e) => Err(format!("Expected Unauthorized error, got: {}", e)),
            Ok(_) => Err("Connection should have been rejected with invalid token".to_string()),
        }
    })
    .await
}

/// Test 3: Connection with valid token should succeed
async fn test_valid_token_accepted() -> TestResult {
    run_test("Auth: Valid token accepted", || async {
        let (url, validator, handle) = create_secure_router().await;

        // Register a valid token with full access
        let token = CpskValidator::generate_token();
        let scopes = vec![Scope::parse("admin:/**").unwrap()];
        validator.register(token.clone(), TokenInfo::new(token.clone(), scopes));

        let result = connect_with_token(&url, Some(&token)).await;

        handle.abort();

        match result {
            Ok(_) => Ok(()),
            Err(e) => Err(format!("Valid token should be accepted: {}", e)),
        }
    })
    .await
}

/// Test 4: Empty token should be rejected
async fn test_empty_token_rejected() -> TestResult {
    run_test("Auth: Empty token rejected", || async {
        let (url, _validator, handle) = create_secure_router().await;

        let result = connect_with_token(&url, Some("")).await;

        handle.abort();

        match result {
            Err(_) => Ok(()),
            Ok(_) => Err("Empty token should have been rejected".to_string()),
        }
    })
    .await
}

/// Test 5: Token with wrong prefix should be rejected
async fn test_wrong_prefix_rejected() -> TestResult {
    run_test("Auth: Wrong token prefix rejected", || async {
        let (url, _validator, handle) = create_secure_router().await;

        let result =
            connect_with_token(&url, Some("jwt_eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9")).await;

        handle.abort();

        match result {
            Err(_) => Ok(()),
            Ok(_) => Err("Token with wrong prefix should have been rejected".to_string()),
        }
    })
    .await
}

/// Test 6: Write to address outside scope should fail
async fn test_write_scope_enforcement() -> TestResult {
    run_test("Scope: Write outside allowed pattern blocked", || async {
        let (url, validator, handle) = create_secure_router().await;

        // Register token with limited write scope
        let token = CpskValidator::generate_token();
        let scopes = vec![
            Scope::parse("read:/**").unwrap(),
            Scope::parse("write:/allowed/**").unwrap(),
        ];
        validator.register(token.clone(), TokenInfo::new(token.clone(), scopes));

        let (sender, mut receiver) = connect_with_token(&url, Some(&token)).await?;

        // Skip initial snapshot
        tokio::time::sleep(Duration::from_millis(100)).await;
        while let Ok(Some(TransportEvent::Data(_))) =
            timeout(Duration::from_millis(50), receiver.recv()).await
        {}

        // Try to write to allowed address - should succeed
        let allowed = try_set(&sender, &mut receiver, "/allowed/test", Value::Float(1.0)).await?;

        // Try to write to forbidden address - should fail
        let forbidden =
            try_set(&sender, &mut receiver, "/forbidden/test", Value::Float(1.0)).await?;

        handle.abort();

        if !allowed {
            return Err("Write to allowed address should succeed".to_string());
        }
        if forbidden {
            return Err("Write to forbidden address should be blocked".to_string());
        }

        Ok(())
    })
    .await
}

/// Test 7: Expired token should be rejected
async fn test_expired_token_rejected() -> TestResult {
    run_test("Auth: Expired token rejected", || async {
        let (url, validator, handle) = create_secure_router().await;

        // Register an expired token
        let token = CpskValidator::generate_token();
        let scopes = vec![Scope::parse("admin:/**").unwrap()];
        let info = TokenInfo::new(token.clone(), scopes)
            .with_expires_at(std::time::SystemTime::now() - Duration::from_secs(3600));
        validator.register(token.clone(), info);

        let result = connect_with_token(&url, Some(&token)).await;

        handle.abort();

        match result {
            Err(e) if e.contains("302") || e.contains("expired") || e.contains("Expired") => Ok(()),
            Err(e) => Err(format!("Expected TokenExpired error, got: {}", e)),
            Ok(_) => Err("Expired token should have been rejected".to_string()),
        }
    })
    .await
}

/// Test 8: Revoked token should be rejected
async fn test_revoked_token_rejected() -> TestResult {
    run_test("Auth: Revoked token rejected", || async {
        let (url, validator, handle) = create_secure_router().await;

        // Register and then revoke a token
        let token = CpskValidator::generate_token();
        let scopes = vec![Scope::parse("admin:/**").unwrap()];
        validator.register(token.clone(), TokenInfo::new(token.clone(), scopes));
        validator.revoke(&token);

        let result = connect_with_token(&url, Some(&token)).await;

        handle.abort();

        match result {
            Err(_) => Ok(()),
            Ok(_) => Err("Revoked token should have been rejected".to_string()),
        }
    })
    .await
}

/// Test 9: SQL injection in token should be rejected (not cause crash)
async fn test_sql_injection_safe() -> TestResult {
    run_test("Security: SQL injection in token doesn't crash", || async {
        let (url, _validator, handle) = create_secure_router().await;

        let malicious_tokens = vec![
            "cpsk_'; DROP TABLE tokens; --",
            "cpsk_\" OR \"1\"=\"1",
            "cpsk_<script>alert('xss')</script>",
            "cpsk_\0\0\0\0",
            "cpsk_../../../etc/passwd",
        ];

        for token in malicious_tokens {
            let result = connect_with_token(&url, Some(token)).await;
            // Should fail but not crash
            if result.is_ok() {
                handle.abort();
                return Err(format!("Malicious token should be rejected: {}", token));
            }
        }

        handle.abort();
        Ok(())
    })
    .await
}

/// Test 10: Moderately long token should be handled gracefully
async fn test_long_token_handled() -> TestResult {
    run_test("Security: Long token handled gracefully", || async {
        let (url, _validator, handle) = create_secure_router().await;

        // Create a moderately long token (1KB - fits in WS message but is still unusual)
        let long_token = format!("cpsk_{}", "A".repeat(1000));

        let result = connect_with_token(&url, Some(&long_token)).await;

        handle.abort();

        // Should fail but not crash
        match result {
            Err(_) => Ok(()),
            Ok(_) => Err("Long invalid token should have been rejected".to_string()),
        }
    })
    .await
}

/// Test 11: Read scope enforcement via SUBSCRIBE
async fn test_read_scope_enforcement() -> TestResult {
    run_test(
        "Scope: Subscribe outside allowed pattern blocked",
        || async {
            let (url, validator, handle) = create_secure_router().await;

            // Register token with limited read scope
            let token = CpskValidator::generate_token();
            let scopes = vec![Scope::parse("read:/allowed/**").unwrap()];
            validator.register(token.clone(), TokenInfo::new(token.clone(), scopes));

            let (sender, mut receiver) = connect_with_token(&url, Some(&token)).await?;

            // Skip initial messages
            tokio::time::sleep(Duration::from_millis(100)).await;
            while let Ok(Some(TransportEvent::Data(_))) =
                timeout(Duration::from_millis(50), receiver.recv()).await
            {}

            // Try to subscribe to forbidden pattern
            let subscribe = Message::Subscribe(SubscribeMessage {
                id: 1,
                pattern: "/forbidden/**".to_string(),
                types: vec![],
                options: None,
            });

            sender
                .send(codec::encode(&subscribe).unwrap())
                .await
                .map_err(|e| format!("Send failed: {:?}", e))?;

            // Check for error response
            let response = timeout(Duration::from_secs(2), async {
                loop {
                    if let Some(TransportEvent::Data(data)) = receiver.recv().await {
                        let (msg, _) = codec::decode(&data).unwrap();
                        match msg {
                            Message::Error(err) => return Some(err),
                            Message::Ack(_) => return None, // Subscription was accepted - should not happen
                            _ => continue,
                        }
                    }
                }
            })
            .await;

            handle.abort();

            match response {
                Ok(Some(_err)) => Ok(()), // Got error as expected
                Ok(None) => Err("Subscribe to forbidden pattern should be blocked".to_string()),
                Err(_) => Ok(()), // Timeout might mean it was silently dropped, which is acceptable
            }
        },
    )
    .await
}

/// Test 12: Token with only admin scope should have full access
async fn test_admin_scope_full_access() -> TestResult {
    run_test("Scope: Admin scope grants full access", || async {
        let (url, validator, handle) = create_secure_router().await;

        let token = CpskValidator::generate_token();
        let scopes = vec![Scope::parse("admin:/**").unwrap()];
        validator.register(token.clone(), TokenInfo::new(token.clone(), scopes));

        let (sender, mut receiver) = connect_with_token(&url, Some(&token)).await?;

        // Skip initial messages
        tokio::time::sleep(Duration::from_millis(100)).await;
        while let Ok(Some(TransportEvent::Data(_))) =
            timeout(Duration::from_millis(50), receiver.recv()).await
        {}

        // Admin should be able to write anywhere
        let result1 = try_set(&sender, &mut receiver, "/any/path", Value::Float(1.0)).await?;
        let result2 = try_set(
            &sender,
            &mut receiver,
            "/system/critical",
            Value::Float(2.0),
        )
        .await?;

        handle.abort();

        if !result1 || !result2 {
            return Err("Admin should have full write access".to_string());
        }

        Ok(())
    })
    .await
}

/// Test 13: Multiple simultaneous connections with different tokens
async fn test_multiple_tokens_isolation() -> TestResult {
    run_test(
        "Isolation: Different tokens have isolated scopes",
        || async {
            let (url, validator, handle) = create_secure_router().await;

            // Token A: can only write to /a/**
            let token_a = CpskValidator::generate_token();
            let scopes_a = vec![
                Scope::parse("read:/**").unwrap(),
                Scope::parse("write:/a/**").unwrap(),
            ];
            validator.register(token_a.clone(), TokenInfo::new(token_a.clone(), scopes_a));

            // Token B: can only write to /b/**
            let token_b = CpskValidator::generate_token();
            let scopes_b = vec![
                Scope::parse("read:/**").unwrap(),
                Scope::parse("write:/b/**").unwrap(),
            ];
            validator.register(token_b.clone(), TokenInfo::new(token_b.clone(), scopes_b));

            // Connect both
            let (sender_a, mut receiver_a) = connect_with_token(&url, Some(&token_a)).await?;
            let (sender_b, mut receiver_b) = connect_with_token(&url, Some(&token_b)).await?;

            // Skip initial messages
            tokio::time::sleep(Duration::from_millis(100)).await;
            while let Ok(Some(TransportEvent::Data(_))) =
                timeout(Duration::from_millis(50), receiver_a.recv()).await
            {}
            while let Ok(Some(TransportEvent::Data(_))) =
                timeout(Duration::from_millis(50), receiver_b.recv()).await
            {}

            // A can write to /a but not /b
            let a_to_a = try_set(&sender_a, &mut receiver_a, "/a/test", Value::Float(1.0)).await?;
            let a_to_b = try_set(&sender_a, &mut receiver_a, "/b/test", Value::Float(1.0)).await?;

            // B can write to /b but not /a
            let b_to_b = try_set(&sender_b, &mut receiver_b, "/b/test", Value::Float(2.0)).await?;
            let b_to_a = try_set(&sender_b, &mut receiver_b, "/a/test", Value::Float(2.0)).await?;

            handle.abort();

            if !a_to_a {
                return Err("Token A should be able to write to /a/**".to_string());
            }
            if a_to_b {
                return Err("Token A should NOT be able to write to /b/**".to_string());
            }
            if !b_to_b {
                return Err("Token B should be able to write to /b/**".to_string());
            }
            if b_to_a {
                return Err("Token B should NOT be able to write to /a/**".to_string());
            }

            Ok(())
        },
    )
    .await
}

/// Test 14: Token entropy check
async fn test_token_entropy() -> TestResult {
    run_test(
        "Security: Generated tokens have sufficient entropy",
        || async {
            // Generate multiple tokens and check they're all different
            let mut tokens = std::collections::HashSet::new();
            for _ in 0..1000 {
                let token = CpskValidator::generate_token();
                if tokens.contains(&token) {
                    return Err("Token collision detected - insufficient entropy".to_string());
                }
                tokens.insert(token);
            }

            // Check token length
            let sample = CpskValidator::generate_token();
            if sample.len() < 37 {
                return Err(format!("Token too short: {} chars", sample.len()));
            }

            // Check prefix
            if !sample.starts_with("cpsk_") {
                return Err("Token missing cpsk_ prefix".to_string());
            }

            Ok(())
        },
    )
    .await
}

/// Test 15: Open mode should allow all connections
async fn test_open_mode_allows_all() -> TestResult {
    run_test(
        "Mode: Open mode allows connections without token",
        || async {
            let port = find_available_port().await;
            let addr = format!("127.0.0.1:{}", port);
            let url = format!("ws://{}", addr);

            // Create router in OPEN mode
            let router = Router::new(RouterConfig {
                name: "Open Router".to_string(),
                max_sessions: 100,
                session_timeout: 60,
                features: vec!["param".to_string()],
                security_mode: SecurityMode::Open,
                max_subscriptions_per_session: 1000,
        gesture_coalescing: true,
        gesture_coalesce_interval_ms: 16,
            });

            let handle = tokio::spawn({
                let addr = addr.clone();
                async move {
                    let _ = router.serve_websocket(&addr).await;
                }
            });

            tokio::time::sleep(Duration::from_millis(100)).await;

            // Should connect without token
            let result = connect_with_token(&url, None).await;

            handle.abort();

            match result {
                Ok(_) => Ok(()),
                Err(e) => Err(format!("Open mode should allow connections: {}", e)),
            }
        },
    )
    .await
}

// ============================================================================
// Main Entry Point
// ============================================================================

#[tokio::main]
async fn main() {
    println!("\n   _____ _        _    ____  ____  ");
    println!("  / ____| |      / \\  / ___||  _ \\ ");
    println!(" | |    | |     / _ \\ \\___ \\| |_) |");
    println!(" | |____| |___ / ___ \\ ___) |  __/ ");
    println!("  \\_____|_____/_/   \\_\\____/|_|    ");
    println!("\n  Security Penetration Tests");
    println!("  Testing CPSK Token Authentication\n");

    let mut suite = TestSuite::new();

    // Authentication tests
    suite.add_result(test_no_token_rejected().await);
    suite.add_result(test_invalid_token_rejected().await);
    suite.add_result(test_valid_token_accepted().await);
    suite.add_result(test_empty_token_rejected().await);
    suite.add_result(test_wrong_prefix_rejected().await);
    suite.add_result(test_expired_token_rejected().await);
    suite.add_result(test_revoked_token_rejected().await);

    // Scope enforcement tests
    suite.add_result(test_write_scope_enforcement().await);
    suite.add_result(test_read_scope_enforcement().await);
    suite.add_result(test_admin_scope_full_access().await);
    suite.add_result(test_multiple_tokens_isolation().await);

    // Security robustness tests
    suite.add_result(test_sql_injection_safe().await);
    suite.add_result(test_long_token_handled().await);
    suite.add_result(test_token_entropy().await);

    // Mode tests
    suite.add_result(test_open_mode_allows_all().await);

    suite.print_summary();

    if suite.all_passed() {
        println!("\x1b[32m✓ All security tests passed! The implementation is secure.\x1b[0m\n");
    } else {
        println!("\x1b[31m✗ Some security tests failed! Review the implementation.\x1b[0m\n");
    }

    std::process::exit(if suite.all_passed() { 0 } else { 1 });
}
